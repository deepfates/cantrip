---
title: "Omar Khattab on X: \"The distinction between LLM \"agents\" and \"workflows\" was always murky and is slowly blurring with ideas like Skills, RLMs, and this concept of Decision-Time Guidance from Replit."
url: "https://x.com/lateinteraction/status/2014685012994515206?rw_tt_thread=True"
date_fetched: "2026-02-16"
type: twitter
---

Title: Omar Khattab on X: "The distinction between LLM "agents" and "workflows" was always murky and is slowly blurring with ideas like Skills, RLMs, and this concept of Decision-Time Guidance from Replit.

Most people define workflows vs. agents in terms of whether the control flow lives in the code or" / X

URL Source: https://x.com/lateinteraction/status/2014685012994515206?rw_tt_thread=True

Published Time: Mon, 16 Feb 2026 20:27:35 GMT

Markdown Content:
Post
----

Conversation
------------

The distinction between LLM "agents" and "workflows" was always murky and is slowly blurring with ideas like Skills, RLMs, and this concept of Decision-Time Guidance from Replit. Most people define workflows vs. agents in terms of whether the control flow lives in the code or not. But that's too simplistic. That's because at some level of abstraction, the control flow *always* lives in the code (a simple agent is also a loop; in fact, autoregressive decoding from the LLM is also a loop). The conventional differences instead are: A) ReAct-style agents tend to accumulate state as history in the prompts. Workflows usually handle state in (code) variables, exposed very selectively to prompts. Obviously, exposing more context to the agent can be good, but also it can be unscalable and distracting (so you end up with hacks like compaction). RLMs split that difference: all context is kept, but the agent has to pull it from variables OR, even better, push it from variables to subcalls. B) ReAct-style agents usually have a fixed instructions/examples section of the prompt, independent of the current state. Workflows obviously have different prompts for different types of states. Replit's Decision-Time Guidance and also Agent Skills split that difference. You can have a long-horizon agent with a coherent identity (single overarching prompt and state) but the agent itself [skills] or the environment/program [Replit's DTG] can pull different instructions at different states. C) ReAct-style agents usually let *only* the LLM dictate control flow except during tool call execution. This has the advantage of being able to work around unforeseen inputs or edge cases, but relying on the LLM for repeated composition makes it hard to scale LLM processing up in a reliable way. RLMs being able to implement workflows at execution time by symbolically writing recursive programs, whose outputs (into variables) it can audit so it can revise them if needed, split this difference. Crucially, it's the model itself that decides these actions in light of its spec.

Quote

Zhen Li

![Image 1](https://pbs.twimg.com/profile_images/1774844664383987715/eJ2WA45U_bigger.jpg)

@zhenthebuilder

Jan 22

We just shipped a technical deep dive on Decision-Time Guidance in @Replit Agent. We discuss how applying control at decision time moves beyond front-loaded rules and repeated reminders. This is relevant for autonomous agents handling real-world, complex tasks.

[Show more](https://x.com/zhenthebuilder/status/2014393451442581688)
