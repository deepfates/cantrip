---
title: "pi is vim"
url: "https://www.generativist.com/notes/2026/Feb/10/pi-is-vim"
date_fetched: "2026-02-16"
type: webpage
---

Title: pi is vim

URL Source: https://www.generativist.com/notes/2026/Feb/10/pi-is-vim

Published Time: 2026-02-10

Markdown Content:
cat /notes/pi-is-vim

vim for coding agents

date: 2026-02-10 author: generativist

You have a preferred harness and you've been using it for months. You understand more than just the basics. You've discovered and developed your own mechanics. They become part of your muscle memory. Then, the model or harness (or both) update. Suddenly your favorite combo move stops working. It's disorienting. What is essentially an extension of your cognition gets remapped without your permission.

_Not your context, not your agent._

This experience at least rhymes with that of IDEs. Me, personally, I switched to vim a decade ago because [Drew Neil did a good job of explaining how it would make me faster](https://pragprog.com/titles/modvim/modern-vim/). If most of coding is actually editing, "editing text at the speed of thought," is a great idea. But that actually undersells vim.

Fire up any popular IDE and you're going to be confronted with a wild excess of features. These features aren't necessarily unused. But the frequency of usefulness is poor compensation for the amount of your visual context occupied. Yes, most IDEs are configurable and extensible. But as tools they always have designed-by-committee aesthetics and bloat.

vim was different. You start with the bare essentials, and then you **_grow_** an environment that suits you. And you keep doing that, over and over again. Every day use reveals an itch. If that itch manifests often enough, you perceive it. Once that happens, you craft something that fits you, rather than buy off the shelf. (Although admittedly, very often the solution is just pulling in someone else's work.)

That's what [pi](https://pi.dev/) feels like to me â€” vim for coding agents.

I still use and try other products. Everyone is really shipping incredible things. And it's hard to understand how new features and mechanics work divorced from the environment they were born in. But now I find myself mostly porting those good experiences back to [pi](https://pi.dev/). In doing so, I have something like deliberate stability. This is doubly useful to me since [pi](https://pi.dev/) extensions can go in `.pi/`, too. When working in a production repo, I get to enjoy a reliable experience. When experimenting, I get to rearrange my lab bench.

[pi](https://pi.dev/) is vim.
